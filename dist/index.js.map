{"version":3,"sources":["webpack://beta/webpack/universalModuleDefinition","webpack://beta/webpack/bootstrap","webpack://beta/./node_modules/webgpu-shader-module-transform/dist/index.js","webpack://beta/./src/clone.ts","webpack://beta/./src/objectInfo.ts","webpack://beta/./src/client.ts","webpack://beta/./src/index.ts"],"names":["root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","e","default","f","navigator","gpu","GPUDevice","createShaderModule","code","label","u","transform","source","cloneProgrammableStageDescriptor","descriptor","entryPoint","cloneRasterizationStateDescriptor","frontFace","cullMode","depthBias","depthBiasSlopeScale","depthBiasClamp","cloneColorStateDescriptor","format","alphaBlend","colorBlend","writeMask","cloneStencilStateFaceDescriptor","compare","failOp","depthFailOp","passOp","cloneDepthStencilStateDescriptor","depthWriteEnabled","depthCompare","stencilFront","stencilBack","stencilReadMask","stencilWriteMask","cloneVertexAttributeDescriptor","offset","shaderLocation","cloneVertexBufferDescriptor","attributes","Error","iterator","arrayStride","stepMode","Array","from","cloneVertexStateDescriptor","vertexBuffers","indexFormat","INFO","randomId","Math","random","toString","substring","initializeShaderModuleInfo","device","obj","info","id","generation","getShaderModuleInfo","getPipelineInfo","fn","onShaderRegistered","_registrationGeneration","_shaderModuleUpdates","Map","_fn","_onShaderRegistered","cloneShaderModuleDescriptor","shaderModule","createRenderPipeline","colorStates","layout","vertexStage","fragmentStage","primitiveTopology","rasterizationState","depthStencilState","vertexState","sampleCount","sampleMask","alphaToCoverageEnabled","cloneRenderPipelineDescriptor","pipeline","registrationGeneration","vertexStageGeneration","fragmentStageGeneration","computeStageGeneration","initializeRenderPipelineInfo","createComputePipeline","computeStage","cloneComputePipelineDescriptor","initializeComputePipelineInfo","registerShaderStage","shaderStage","updatedSource","set","registerRenderPipelineShaders","registerComputePipelineShaders","updateShaderStage","has","shaderSource","replacement","assign","console","error","updatePipeline","size","undefined","vertexStageUpdated","fragmentStageUpdated","computeStageUpdated","setRenderPipeline","encoder","setComputePipeline","install","client","GPURenderPassEncoder","setPipeline","GPUComputePassEncoder"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"beta\"] = factory();\n\telse\n\t\troot[\"beta\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","!function(e,t){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=t():\"function\"==typeof define&&define.amd?define([],t):\"object\"==typeof exports?exports.beta=t():e.beta=t()}(\"undefined\"!=typeof self?self:this,(function(){return function(e){var t={};function r(o){if(t[o])return t[o].exports;var n=t[o]={i:o,l:!1,exports:{}};return e[o].call(n.exports,n,n.exports,r),n.l=!0,n.exports}return r.m=e,r.c=t,r.d=function(e,t,o){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:o})},r.r=function(e){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&\"object\"==typeof e&&e&&e.__esModule)return e;var o=Object.create(null);if(r.r(o),Object.defineProperty(o,\"default\",{enumerable:!0,value:e}),2&t&&\"string\"!=typeof e)for(var n in e)r.d(o,n,function(t){return e[t]}.bind(null,n));return o},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,\"a\",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p=\"\",r(r.s=0)}([function(e,t,r){\"use strict\";r.r(t),r.d(t,\"default\",(function(){return f}));var o=void 0;navigator.gpu&&(o=GPUDevice.prototype.createShaderModule);var n={code:void 0,label:void 0};function u(e){return e.transform&&e.source?n.code=e.transform(e.source):n.code=e.code,o.call(this,n)}function f(){navigator.gpu&&o!==u&&(GPUDevice.prototype.createShaderModule=u)}}])}));\n//# sourceMappingURL=index.js.map","import { GPUShaderModuleDescriptorWithTransform } from 'webgpu-shader-module-transform';\n\nexport const cloneShaderModuleDescriptor = (descriptor?: GPUShaderModuleDescriptorWithTransform) => (descriptor && {\n    code: descriptor.code,\n    source: descriptor.source,\n    transform: descriptor.transform,\n} as GPUShaderModuleDescriptorWithTransform);\n\nexport const cloneProgrammableStageDescriptor = (descriptor?: GPUProgrammableStageDescriptor) => (descriptor && {\n    module: descriptor.module,\n    entryPoint: descriptor.entryPoint,\n} as GPUProgrammableStageDescriptor);\n\nexport const cloneRasterizationStateDescriptor = (descriptor?: GPURasterizationStateDescriptor) => (descriptor && {\n    frontFace: descriptor.frontFace,\n    cullMode: descriptor.cullMode,\n    depthBias: descriptor.depthBias,\n    depthBiasSlopeScale: descriptor.depthBiasSlopeScale,\n    depthBiasClamp: descriptor.depthBiasClamp,\n} as GPURasterizationStateDescriptor);\n\nexport const cloneColorStateDescriptor = (descriptor?: GPUColorStateDescriptor) => (descriptor && {\n    format: descriptor.format,\n    alphaBlend: descriptor.alphaBlend,\n    colorBlend: descriptor.colorBlend,\n    writeMask: descriptor.writeMask,\n} as GPUColorStateDescriptor);\n\nexport const cloneStencilStateFaceDescriptor = (descriptor?: GPUStencilStateFaceDescriptor) => (descriptor && {\n    compare: descriptor.compare,\n    failOp: descriptor.failOp,\n    depthFailOp: descriptor.depthFailOp,\n    passOp: descriptor.passOp,\n} as GPUStencilStateFaceDescriptor);\n\nexport const cloneDepthStencilStateDescriptor = (descriptor?: GPUDepthStencilStateDescriptor) => (descriptor && {\n    format: descriptor.format,\n    depthWriteEnabled: descriptor.depthWriteEnabled,\n    depthCompare: descriptor.depthCompare,\n    stencilFront: cloneStencilStateFaceDescriptor(descriptor.stencilFront),\n    stencilBack: cloneStencilStateFaceDescriptor(descriptor.stencilBack),\n    stencilReadMask: descriptor.stencilReadMask,\n    stencilWriteMask: descriptor.stencilWriteMask,\n} as GPUDepthStencilStateDescriptor);\n\nexport const cloneVertexAttributeDescriptor = (descriptor?: GPUVertexAttributeDescriptor) => (descriptor && {\n    offset: descriptor.offset,\n    format: descriptor.format,\n    shaderLocation: descriptor.shaderLocation,\n} as GPUVertexAttributeDescriptor);\n\nexport const cloneVertexBufferDescriptor = (descriptor?: GPUVertexBufferLayoutDescriptor) => {\n    if (!descriptor) {\n        return undefined;\n    }\n    if (!descriptor.attributes) {\n        throw new Error('Missing attributes');\n    }\n    if (typeof descriptor.attributes[Symbol.iterator] !== 'function') {\n        throw new Error('attributes is not iterable');\n    }\n    return {\n        arrayStride: descriptor.arrayStride,\n        stepMode: descriptor.stepMode,\n        attributes: Array.from(descriptor.attributes, cloneVertexAttributeDescriptor),\n    } as GPUVertexBufferLayoutDescriptor;\n}\n\nexport const cloneVertexStateDescriptor = (descriptor?: GPUVertexStateDescriptor) => {\n    if (!descriptor) {\n        return undefined;\n    }\n    if (descriptor.vertexBuffers && typeof descriptor.vertexBuffers[Symbol.iterator] !== 'function') {\n        throw new Error('vertexBuffers is not iterable');\n    }\n    return {\n        indexFormat: descriptor.indexFormat,\n        vertexBuffers: descriptor.vertexBuffers && Array.from(descriptor.vertexBuffers, cloneVertexBufferDescriptor),\n    } as GPUVertexStateDescriptor;\n}\n\nexport const cloneRenderPipelineDescriptor = (descriptor?: GPURenderPipelineDescriptor) => {\n    if (!descriptor) {\n        return undefined;\n    }\n    if (!descriptor.colorStates) {\n        throw new Error('Missing colorStates');\n    }\n    if (typeof descriptor.colorStates[Symbol.iterator] !== 'function') {\n        throw new Error('colorStates is not iterable');\n    }\n    return {\n        layout: descriptor.layout,\n        vertexStage: cloneProgrammableStageDescriptor(descriptor.vertexStage),\n        fragmentStage: cloneProgrammableStageDescriptor(descriptor.fragmentStage),\n        primitiveTopology: descriptor.primitiveTopology,\n        rasterizationState: cloneRasterizationStateDescriptor(descriptor.rasterizationState),\n        colorStates: Array.from(descriptor.colorStates, cloneColorStateDescriptor),\n        depthStencilState: cloneDepthStencilStateDescriptor(descriptor.depthStencilState),\n        vertexState: cloneVertexStateDescriptor(descriptor.vertexState),\n        sampleCount: descriptor.sampleCount,\n        sampleMask: descriptor.sampleMask,\n        alphaToCoverageEnabled: descriptor.alphaToCoverageEnabled,\n    } as GPURenderPipelineDescriptor;\n};\n\nexport const cloneComputePipelineDescriptor = (descriptor?: GPUComputePipelineDescriptor) => (descriptor && {\n    layout: descriptor.layout,\n    computeStage: cloneProgrammableStageDescriptor(descriptor.computeStage),\n} as GPUComputePipelineDescriptor);\n","import { GPUShaderModuleDescriptorWithTransform } from 'webgpu-shader-module-transform';\n\nconst INFO = \"__WEBGPU_LIVE_SHADER_INFO__\";\n\ntype GPUShaderModuleInfo = {\n    device: GPUDevice,\n    descriptor: GPUShaderModuleDescriptorWithTransform,\n    id: string,\n    replacement?: GPUShaderModule,\n    generation: number,\n}\n\ntype GPUPipelineInfo = {\n    device: GPUDevice,\n    descriptor: GPURenderPipelineDescriptor | GPUComputePipelineDescriptor,\n    replacement?: GPURenderPipeline,\n    registrationGeneration: number,\n    vertexStageGeneration: number,\n    fragmentStageGeneration: number,\n    computeStageGeneration: number,\n}\n\ninterface GPUShaderModuleWithInfo extends GPUShaderModule {\n    [INFO]: GPUShaderModuleInfo\n}\n\ninterface GPURenderPipelineWithInfo extends GPURenderPipeline {\n    [INFO]: GPUPipelineInfo\n}\n\ninterface GPUComputePipelineWithInfo extends GPUComputePipeline {\n    [INFO]: GPUPipelineInfo\n}\n\nconst randomId = () => Math.random().toString(36).substring(2, 15);\n\nexport function initializeShaderModuleInfo(device: GPUDevice, descriptor: GPUShaderModuleDescriptorWithTransform, obj: GPUShaderModule): GPUShaderModuleInfo {\n    if (INFO in obj) {\n        return (obj as GPUShaderModuleWithInfo)[INFO];\n    }\n    const info: GPUShaderModuleInfo = {\n        device,\n        descriptor,\n        id: randomId(),\n        generation: 0,\n    };\n    (obj as GPUShaderModuleWithInfo)[INFO] = info;\n    return info;\n}\n\nexport function initializeRenderPipelineInfo(device: GPUDevice, descriptor: GPURenderPipelineDescriptor, obj: GPURenderPipeline): GPUPipelineInfo {\n    if (INFO in obj) {\n        return (obj as GPURenderPipelineWithInfo)[INFO];\n    }\n    const info: GPUPipelineInfo = {\n        device,\n        descriptor,\n        registrationGeneration: 0,\n        vertexStageGeneration: 0,\n        fragmentStageGeneration: 0,\n        computeStageGeneration: 0,\n    };\n    (obj as GPURenderPipelineWithInfo)[INFO] = info;\n    return info;\n}\n\nexport function initializeComputePipelineInfo(device: GPUDevice, descriptor: GPUComputePipelineDescriptor, obj: GPUComputePipeline): GPUPipelineInfo {\n    if (INFO in obj) {\n        return (obj as GPUComputePipelineWithInfo)[INFO];\n    }\n    const info: GPUPipelineInfo = {\n        device,\n        descriptor,\n        registrationGeneration: 0,\n        vertexStageGeneration: 0,\n        fragmentStageGeneration: 0,\n        computeStageGeneration: 0,\n    };\n    (obj as GPUComputePipelineWithInfo)[INFO] = info;\n    return info;\n}\n\nexport function getShaderModuleInfo(obj: GPUShaderModule): GPUShaderModuleInfo {\n    return (obj as GPUShaderModuleWithInfo)[INFO];\n}\n\nexport function getPipelineInfo(obj: GPURenderPipeline | GPUComputePipeline) {\n    return (obj as GPURenderPipelineWithInfo | GPUComputePipelineWithInfo)[INFO];\n}\n","\nimport { GPUDeviceWithShaderModuleDescriptorTransform, GPUShaderModuleDescriptorWithTransform, GPUShaderSource } from 'webgpu-shader-module-transform';\nimport { cloneShaderModuleDescriptor, cloneRenderPipelineDescriptor, cloneComputePipelineDescriptor } from './clone';\nimport { initializeShaderModuleInfo, initializeRenderPipelineInfo, initializeComputePipelineInfo, getPipelineInfo, getShaderModuleInfo } from './objectInfo';\n\ntype ClientFunctions = {\n    createShaderModule: GPUDeviceWithShaderModuleDescriptorTransform[\"createShaderModule\"],\n    createRenderPipeline: GPUDevice[\"createRenderPipeline\"],\n    createComputePipeline: GPUDevice[\"createComputePipeline\"],\n    setRenderPipeline: GPURenderPassEncoder[\"setPipeline\"],\n    setComputePipeline: GPUComputePassEncoder[\"setPipeline\"]\n}\n\nexport type OnShaderRegisteredCallback = (source: GPUShaderSource, updateCallback: (updatedSource: GPUShaderSource) => void) => void;\n\nexport default class Client {\n    _fn: ClientFunctions;\n    _registrationGeneration: number = 1;\n    _shaderModuleUpdates: Map<string, GPUShaderSource> = new Map();\n    _onShaderRegistered?: OnShaderRegisteredCallback;\n\n    constructor(fn: ClientFunctions, onShaderRegistered?: OnShaderRegisteredCallback) {\n        this._fn = fn;\n        this._onShaderRegistered = onShaderRegistered;\n    }\n\n    createShaderModule(device: GPUDeviceWithShaderModuleDescriptorTransform, descriptor: GPUShaderModuleDescriptorWithTransform): GPUShaderModule {\n        descriptor = cloneShaderModuleDescriptor(descriptor)!;\n\n        const shaderModule = this._fn.createShaderModule.call(device, descriptor);\n        initializeShaderModuleInfo(device, descriptor, shaderModule);\n\n        return shaderModule;\n    }\n\n    createRenderPipeline(device: GPUDevice, descriptor: GPURenderPipelineDescriptor): GPURenderPipeline {\n        descriptor = cloneRenderPipelineDescriptor(descriptor)!;\n\n        const pipeline = this._fn.createRenderPipeline.call(device, descriptor);\n        initializeRenderPipelineInfo(device, descriptor, pipeline);\n\n        return pipeline;\n    }\n\n    createComputePipeline(device: GPUDevice, descriptor: GPUComputePipelineDescriptor): GPUComputePipeline {\n        descriptor = cloneComputePipelineDescriptor(descriptor)!;\n\n        const pipeline = this._fn.createComputePipeline.call(device, descriptor);\n        initializeComputePipelineInfo(device, descriptor, pipeline);\n\n        return pipeline;\n    }\n\n    private registerShaderStage(shaderStage?: GPUProgrammableStageDescriptor) {\n        if (!shaderStage || !shaderStage.module) {\n            return;\n        }\n\n        const shaderModule = shaderStage.module;\n        const info = getShaderModuleInfo(shaderModule);\n\n        if (this._onShaderRegistered && info.descriptor.source && info.descriptor.transform) {\n            this._onShaderRegistered(info.descriptor.source, (updatedSource: GPUShaderSource) => {\n                this._shaderModuleUpdates.set(info.id, updatedSource);\n            });\n        }\n    }\n\n    private registerRenderPipelineShaders(pipeline: GPURenderPipeline) {\n        const info = getPipelineInfo(pipeline);\n        if (info.registrationGeneration === this._registrationGeneration) {\n            return;\n        }\n        info.registrationGeneration = this._registrationGeneration;\n\n        const descriptor = info.descriptor as GPURenderPipelineDescriptor;\n        this.registerShaderStage(descriptor.vertexStage);\n        this.registerShaderStage(descriptor.fragmentStage);\n    }\n\n    private registerComputePipelineShaders(pipeline: GPUComputePipeline) {\n        const info = getPipelineInfo(pipeline);\n        if (info.registrationGeneration === this._registrationGeneration) {\n            return;\n        }\n        info.registrationGeneration = this._registrationGeneration;\n\n        const descriptor = info.descriptor as GPUComputePipelineDescriptor;\n        this.registerShaderStage(descriptor.computeStage);\n    }\n\n    private updateShaderStage(shaderStage?: GPUProgrammableStageDescriptor): number | undefined {\n        if (!shaderStage || !shaderStage.module) {\n            return undefined;\n        }\n\n        const shaderModule = shaderStage.module;\n        const info = getShaderModuleInfo(shaderModule);\n\n        if (this._shaderModuleUpdates.has(info.id)) {\n            const shaderSource = this._shaderModuleUpdates.get(info.id);\n            info.descriptor.source = shaderSource;\n\n            this._shaderModuleUpdates.delete(info.id);\n\n            try {\n                const replacement = this._fn.createShaderModule.call(info.device, info.descriptor);\n                initializeShaderModuleInfo(info.device, info.descriptor, replacement);\n                Object.assign(getShaderModuleInfo(replacement), info);\n\n                info.replacement = replacement;\n                info.generation += 1;\n            } catch (e) {\n                console.error(e);\n            }\n        }\n\n        return info.generation;\n    }\n\n    private updatePipeline(pipeline: GPURenderPipeline | GPUComputePipeline) {\n        if (this._shaderModuleUpdates.size === 0) {\n            return;\n        }\n\n        const info = getPipelineInfo(pipeline);\n        const descriptor = info.descriptor;\n\n        let vertexStageGeneration = undefined;\n        let fragmentStageGeneration = undefined;\n        let computeStageGeneration = undefined;\n\n        if ('vertexStage' in descriptor) {\n            vertexStageGeneration = this.updateShaderStage(descriptor.vertexStage);\n        }\n        if ('fragmentStage' in descriptor) {\n            fragmentStageGeneration = this.updateShaderStage(descriptor.fragmentStage);\n        }\n        if ('computeStage' in descriptor) {\n            computeStageGeneration = this.updateShaderStage(descriptor.computeStage);\n        }\n\n        const vertexStageUpdated = (vertexStageGeneration !== undefined && vertexStageGeneration !== info.vertexStageGeneration);\n        const fragmentStageUpdated = (fragmentStageGeneration !== undefined && fragmentStageGeneration !== info.fragmentStageGeneration);\n        const computeStageUpdated = (computeStageGeneration !== undefined && computeStageGeneration !== info.computeStageGeneration);\n\n        if (!(vertexStageUpdated || fragmentStageUpdated || computeStageUpdated)) {\n            return;\n        }\n\n        if (vertexStageUpdated) {\n            // @ts-ignore\n            descriptor.vertexStage.module = getShaderModuleInfo(descriptor.vertexStage.module).replacement;\n        }\n\n        if (fragmentStageUpdated) {\n            // @ts-ignore\n            descriptor.fragmentStage.module = getShaderModuleInfo(descriptor.fragmentStage.module).replacement;\n        }\n\n        if (computeStageUpdated) {\n            // @ts-ignore\n            descriptor.computeStage.module = getShaderModuleInfo(descriptor.computeStage.module).replacement;\n        }\n\n        if (vertexStageUpdated || fragmentStageUpdated) {\n            info.replacement = this._fn.createRenderPipeline.call(info.device, descriptor as GPURenderPipelineDescriptor);\n        } else if (computeStageUpdated) {\n            info.replacement = this._fn.createComputePipeline.call(info.device, descriptor as GPUComputePipelineDescriptor);\n        }\n    }\n\n    setRenderPipeline(encoder: GPURenderPassEncoder, pipeline: GPURenderPipeline): void {\n        this.registerRenderPipelineShaders(pipeline);\n        this.updatePipeline(pipeline);\n        pipeline = getPipelineInfo(pipeline).replacement || pipeline;\n        return this._fn.setRenderPipeline.call(encoder, pipeline);\n    }\n\n    setComputePipeline(encoder: GPUComputePassEncoder, pipeline: GPUComputePipeline): void {\n        this.registerComputePipelineShaders(pipeline);\n        this.updatePipeline(pipeline);\n        pipeline = getPipelineInfo(pipeline).replacement || pipeline;\n        return this._fn.setComputePipeline.call(encoder, pipeline);\n    }\n};\n","import Client, { OnShaderRegisteredCallback } from './client';\nimport installShaderCompilerLoader, { GPUDeviceWithShaderModuleDescriptorTransform, GPUShaderModuleDescriptorWithTransform } from 'webgpu-shader-module-transform';\n\nexport default function install(onShaderRegistered?: OnShaderRegisteredCallback) {\n    if (!navigator.gpu) return;\n\n    installShaderCompilerLoader();\n\n    const client = new Client({\n        // @ts-ignore\n        createShaderModule: GPUDevice.prototype.createShaderModule,\n        // @ts-ignore\n        createRenderPipeline: GPUDevice.prototype.createRenderPipeline,\n        // @ts-ignore\n        createComputePipeline: GPUDevice.prototype.createComputePipeline,\n        // @ts-ignore\n        setRenderPipeline: GPURenderPassEncoder.prototype.setPipeline,\n        // @ts-ignore\n        setComputePipeline: GPUComputePassEncoder.prototype.setPipeline,\n    }, onShaderRegistered);\n\n    // @ts-ignore\n    Object.assign(GPUDevice.prototype, {\n        createShaderModule(this: GPUDeviceWithShaderModuleDescriptorTransform, descriptor: GPUShaderModuleDescriptorWithTransform): GPUShaderModule {\n            return client.createShaderModule(this, descriptor);\n        },\n        createRenderPipeline(this: GPUDevice, descriptor: GPURenderPipelineDescriptor): GPURenderPipeline {\n            return client.createRenderPipeline(this, descriptor);\n        },\n        createComputePipeline(this: GPUDevice, descriptor: GPUComputePipelineDescriptor): GPUComputePipeline {\n            return client.createComputePipeline(this, descriptor);\n        }\n    });\n\n    // @ts-ignore\n    Object.assign(GPURenderPassEncoder.prototype, {\n        setPipeline: function setRenderPipeline(this: GPURenderPassEncoder, pipeline: GPURenderPipeline): void {\n            return client.setRenderPipeline(this, pipeline);\n        }\n    });\n\n    // @ts-ignore\n    Object.assign(GPUComputePassEncoder.prototype, {\n        setPipeline: function setComputePipeline(this: GPUComputePassEncoder, pipeline: GPUComputePipeline): void {\n            return client.setComputePipeline(this, pipeline);\n        }\n    });\n}\n\n"],"sourceRoot":""}